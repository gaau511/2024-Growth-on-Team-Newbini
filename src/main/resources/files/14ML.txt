시험 전 요약

손코딩 tf 개념설명
fork exec : shell이 process를 만드는 방법
booting 시 init이 실행 -> fork -> bash process 생성
내가 ls와 같은 명령어를 쓰면 exec 계열의 command로 바꾸어 실행-> 기억잘해놔

exec -> process를 대체하는 함수
지금 프로세스는 죽여
execl, v,e 어떤경우에 뭘쓰는게 좋을지 고민해

예제) docommand

fork -> 완전히 동일한애가 복사 -> file desciptor 도 복사

child / parent p의 다른점

exec는 file을 open하고 부르면 파일이 열려있어
관리를 안하면 꼬여
flag : close on exec를 주면 정리해줌

직관적으로 process를 늘리면 shell에서 하는게 좋지만 서로의 pid를 알 수없음
fork를 이용하면 트리구조 생성

exit -> 사용했던걸 반환하고 exit 해주는 함수임
_exit (시스템 콜) exit(시스템 라이브러리(유저레벨))

exit handle 도 가능

process synchronization
wait() -> parent가 부르는거임 child가 죽을때까지 wait 에서 기다려
정상적으로 끝나면 sigchild를 받음
child가 몇놈이라도 아무놈이라도 죽으면 ㄱ끝나

waitpid는 동일한 기능인데 콕 집어서 누굴 기다리겠다고 하는거야

이러면 프로세스 기본적인건 끝나




















zombie -> parent 가 wait안부르고 그냥 죽어, 아니면 wait을 늦게 불러서 기다려
child는 허락을 받을 애가 없어
나는 끝나서 sigchild를 불렀는데 바쁘거나 wait을 안불러서 기다려

orphan -> zombie의 special case 
부모 프로세스가 죽었어

zombie orphan은 리소스 낭비고, pid 잡고있어서 나빠

여기 잠깐 못들음

pid : process가 가진 유니크한 아이디
0,1 은 선점되어있음

gid : 의외로 많이쓰임 uid는 변경 안되는데 gid는 변경 가능

session은 어떤 shell process로 부터 파생됐는지 알려주는게 session id야
session id를 바꿔주면 그 process 는 그 shell로 권한이 널어감

working directory : 현재 디렉토리
root directory : 
home directory : 내 s12201757 디렉토리

reaul userID랑effective가 어떻게 바뀌는지 보자
오른쪽에 두개는 보지마

ulimit() : 한 파일이 작성할수있는 크기 -> ex)coredump

nice : process 우선순위 -> 그대로 돌아가지 않음

small shell 각자 보세요 쭉 

실습할때 shell드렸죠

















Signal

최소한의 통신
이벤트가 발생하면 os가 user process 한테 알려줘
signal은 상수를 하나 던져주는거야
운영체제가 정해놓은 약속

grateful exit

signal handling 
sigset = 구조체, 시그널을 어떻게 표현할건지 (bitmap)
set에다가 특정 시그널을 표시하고 sigaction을 통해서 handler를 달아줘
구조체 이름도 sigaction, 함수 이름도 sigaction이야

sigcation 내의 sa_mask
내가 handling 하는동안 저 signal들 block 해라

예시 : Catching SIGINT

밑에있는함수 : 조금 더 주고싶으면

systemcall 하는주 signal 발생하면 어떤애들을 처리, 어떤애들은 무시
interruptible 말고 나머지 애들은 하면 안돼


longjmp는 handler 안에서 불러주는거야
setjmp는 깃발 꽂는거고

blocking : signal 받아도 잠깐 기다려봐
kill : p2p signal 보내기

 이런 함수가 이럴때쓰이는구나 정도로 공부해

누가한테 보내는지 알아야돼 euid가 나랑 똑같아야 죽일 수 있어


















가장 원시적인 데이터전송 방법 pipe

filedes를 받아와서 사용

read/ wirte block noblock이 달라
이거 기억해야돼 어떨때 block 되는지 block 안되는지 -> pipe 사용법 숙지

한놈이 닫히면 어케됨 -> 꼭확인

size가 한정 : 한번볼때 4k, 전체가 64k

blocking : default, 데이터 주고받을때까지 기다렸다가 return
non-blocking : 일단 바로 return하고 나중에 확인

select는 pipe여러개 일때 어떻게 모니터 할것인가
readfds, writefds 배열

FIFO는 pipe는 pipe인데 동일한점도 있고 다른점은, process간 아무 연관이 없어도 사용가능
pipe는 트리구조로 묶여있어야만 사용가능





























process 들이 통신을 위해 쓰는건데 좀 특이한 기능들이 있음
파일이름과 descriptor의 차이점, key와 id도 동일
key를 만들면 get을 해 -> id를 넘겨줌 (open과 동일한 기능)

ctl 이것저것 가능

Message queue는 pipe랑 비슷하게 주고 받는데 packet과 다르게 msg는 그런게 없어
그냥 보내 특정 byte 하나 보낼때마다 덕지덕지 붙음
pipe는 순서대로 받아야하고, msg는 type 을 통해 순서 
rcv의 세번째를 통해 어떤걸 받을지 판단

semaphore 엄밀히 말하면 통신은 아니야
공유자원을 보호해줄 뿐이야
세마포어는 여러개를 동시에 만들 수 있다.
op_array 하나여도 그냥 array로 받아

semaphore가 원래 초기값 S가 있어
들어가고 나올때 +- 1 씩 해줘, 0이 되면 못들어가 양수여야 돼
퀴즈 :2

shared memory : thread 를 모방
마치 메모리 공간이 보이는 것 처럼 attach/ detach
실습 안해봄, 회의적임, 예제 보긴 봐























메모리간의 데이터이동이 아니라 다른 컴퓨터끼리 통신을 통해 데이터를 주고 받아
tcp : 커넥션 만들고 통신 udp : 냅다 주소로 보내기

accept에서 중요한거, 상대방 주소를 알아야해
file이랑 매우 비슷
10쪽의 그림만 제대로 이해하기

scockaddr_in 조금 더 기능이 들어간거

socket은 열어주면 생겨, open 이랑 똑같아 
보통은 옵션은 stream을 써

28쪽의 예제를 거의 그대로 씀

recevive send 거의 비슷해 file descriptor read write이랑

마지막 udp처럼 통신할수 있는 recvfrom sendto 기능 
connect accept 의 기능이 없음